Проект для работы с экраном на C++

Может есть смысл представить экран не в виде массива - а в виде строк, объединенных в список (через список указателей). Не потребуется тупое умножение. Кодирование символов по-любому не менять - т.к. это стандрт, генерируемый программой.

class View в конструктор передается размер шрифта и текст, экран
в класс экрана - т.к. он содержит шрифты (вынести в отдельный класс?), функция для определения длины строки в определенном шрифте.
Можно экран и класс View (вид) объединить как наследование от общего класса для рисования (который содержит шрифты)
View тоже можно проецировать на View - эта функция может смещать влево и вправо - вызывать в общем цикле через usleep(40) - 25 кадров в секунду

//Конфигурация дисплея - построчно (1 строка в высоту 8 пикселей) слева направо сверху вниз
unsigned char* row_screen[height_LCD/8];
class row_LCD
{
row_LCD(int column) {new data(column);};
~row_LCD(int column) {delete data(column);};
public:
write(int column);
read(int column) const;
const* get_row(int i) const;//Посмотреть итераторы
private:
unsigned char* data;
}

abstuct class ProtoView
class View : public ProtoView
{
row_LCD* rows[height_LCD/8];
}
Может сделать массив классов row_lcd - кажется будут проблемы, если будет наследование - сделать isolated?

Для получения данных с интернета используется (Написание HTTP-запросов с помощью Curl):
http://curl.haxx.se/libcurl/c/example.html
НЕТ /*Установка http://curl.haxx.se/download.html
Скачать в отдельную папку
произвести компиляцию, выполнить scripts (установить им флаг execute):
./curl-config --cflags
./curl-config --libs*/
Вместо этого: sudo apt-get install libcurl4-openssl-dev
Описание утилиты CURL http://rus-linux.net/MyLDP/internet/curlrus.html
Описание работы на С++ на русском:
http://programmersforum.ru/showthread.php?t=60338

Для обработки XML файла установить:
sudo apt-get install libtinyxml-dev

//Для вывода символов на экран требуется Windows-1251 - т.к. там это закодированно программой
//Преобразования UTF-8 ->Windows-1251 можно выполнить с помощью

    //UTF8 to/from wide char conversion in STL
    //http://stackoverflow.com/questions/148403/utf8-to-from-wide-char-conversion-in-stl

    //Simple iconv (libiconv) example
    //http://blog.inventic.eu/2010/11/simple-iconv-libiconv-example/
    //http://dendroudnotes.blogspot.ru/2011/02/iconv-c.html


Можно сделать отдельную программу-конвертор, которая бы использовала .h файл со шрифтом и формировала бинарный файл с компактной структорой, т.е. отсутсвием лишних нулей
и модуль загрузки шрифта - развертывание в памяти массива данных = исключить некрасивость в коде

НЕТ: Также можно было бы сделать перестановку символов в код UTF-8, чтобы избежать лишней перекодировки при каждом выводе на экран
НЕТ: Т.е. набор чисел от 0 до 256 необходимо преобразовать в другую кодировку, а потом данные символов расставить в нужном порядке
Не получиться - UTF-8 при установленном 1 бите числа является многобайтовым, что приводит к очень сложному кодированию до 4 байт длины
http://ru.wikipedia.org/wiki/UTF-8
Т.е. по любому требуется преобразование к 255 символам

Хранение шрифтов, преобразование к удобному виду вынести в отдельный класс (файл) - типа фабрика - static метод возвращающий готовый класс


Можно на выходе сформировать 2 массива: 1 содержит ширину каждого символа, 2 содержит просто огромный масссив данных (не будет лишних нулей и он займет меньше места в памяти)
при загрузке сформировать массив Symbol - суммирование указателя и ширины символа
class Symbol
{
ushort width;
unsigned char* data;
}
символ должен уметь рисовать сам себя

Ещё можно разместить данные шрифта в более удобном виде - переставить порядок следования байт, чтобы копирование можно было осуществлять последовательно

Посмотреть другие форматы, возвращаемые программой sym и т.д.

ОШИБКИ!!! Т.е. имеет место в этом проекте изначальная ошибка проектирования - его вообще не было
ОШИБКИ!!! Была попытка вместо преобразования шрифтов к удобному виде подстроиться по эти данные

Можно сделать не векторы, а строки отображаются на один непрерывный участок памяти, где 1 байт команда для дисплея - экономия на копировании данных
Так они копируются 2 раза - в буфер экрана, а затем в буфер шины I2C
Т.е. можно выполнить в виде ещё одного класса View

Debug_output_console();
Сделать функцию во View - выводящую содержимое View на терминал в виде звезедочек - почти помещается (лучше использовать кодирование по 2 символа в одном экранном символе)
█▌▐

Лучше что были символы по квадратиками - т.е. по 4 в одном эранном символе
▀▄█▌▐

▀▄█ 

Можно выводить в файл и при отображении изменить в настройках окна консоли выводимый шрифт - сделать его размер минимальным
Символы выводяться по 8 бит вертикально - т.е. можно объединить по 2 по вертикали ▀▄█
Вначале сформировать массив строк 133х32 и туда записывать, после вывод на экран

\x1B[32F
Как управлять курсором и цветом (\x1b[30m)
http://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8_ANSI
http://en.wikipedia.org/wiki/ANSI_escape_code

Решение: т.к. шрифты уже сгенерированы и проверены на экране - использовать их
Загрузку организовать в виду синглтон объекта

Лучше Debug делать в BMP файл
http://easybmp.sourceforge.net/

BMP AnImage;
AnImage.SetSize(133,64);
AnImage.SetBitDepth(24);

for(ushort i=0;i<64;i++)
{
AnImage(i,i)->Red = 255;
AnImage(i,i)->Green = 0;
AnImage(i,i)->Blue = 0;
AnImage(i,i)->Alpha = 0;
}

***** СТАРОЕ

Компиляция одного файла
gcc main.cc -o main

С использованием std заработало только при
g++ main.cc -o main

Периодически возникает ошибка
classA.h:1:1: error: unknown type name ‘class’
classA.h:2:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token
РЕШЕНИЕ: повторная перекомпиляция
Что-то часто возникают подобные ошибки - нужен ReBuild All?

Запуск sudo ./main


const int* - слева от * - данные
int* const - справа от * - константный указатель
http://books.google.ru/books?id=uPvvxRYj-NIC&pg=PA380&lpg=PA380&dq=C%2B%2B+const+%D1%81%D0%BB%D0%B5%D0%B2%D0%B0+%D0%BE%D1%82+*&source=bl&ots=K5mme-V8bM&sig=tPk_0Vzqx5yivPZRbK9VykQnijY&hl=ru&sa=X&ei=V2n8UsHLF_H44QTw0ICoAQ&ved=0CC8Q6AEwAQ#v=onepage&q=C%2B%2B%20const%20%D1%81%D0%BB%D0%B5%D0%B2%D0%B0%20%D0%BE%D1%82%20*&f=false


//Страуструп - прочитано 5-5.2
Читать 5.3 - Но перед этим нужно прочитать главу 3 - т.к. код построен на программе калькулятор стр. 70


Основной проект:
компиляция sudo make
запуск sudo ./prog


