Проект для работы с экраном на C++

Может есть смысл представить экран не в виде массива - а в виде строк, объединенных в список (через список указателей). Не потребуется тупое умножение. Кодирование символов по-любому не менять - т.к. это стандрт, генерируемый программой.

class View в конструктор передается размер шрифта и текст, экран
в класс экрана - т.к. он содержит шрифты (вынести в отдельный класс?), функция для определения длины строки в определенном шрифте.
Можно экран и класс View (вид) объединить как наследование от общего класса для рисования (который содержит шрифты)
View тоже можно проецировать на View - эта функция может смещать влево и вправо - вызывать в общем цикле через usleep(40) - 25 кадров в секунду

//Конфигурация дисплея - построчно (1 строка в высоту 8 пикселей) слева направо сверху вниз
unsigned char* row_screen[height_LCD/8];
class row_LCD
{
row_LCD(int column) {new data(column);};
~row_LCD(int column) {delete data(column);};
public:
write(int column);
read(int column) const;
const* get_row(int i) const;//Посмотреть итераторы
private:
unsigned char* data;
}

abstuct class ProtoView
class View : public ProtoView
{
row_LCD* rows[height_LCD/8];
}
Может сделать массив классов row_lcd - кажется будут проблемы, если будет наследование - сделать isolated?

Для получения данных с интернета используется (Написание HTTP-запросов с помощью Curl):
http://curl.haxx.se/libcurl/c/example.html
НЕТ /*Установка http://curl.haxx.se/download.html
Скачать в отдельную папку
произвести компиляцию, выполнить scripts (установить им флаг execute):
./curl-config --cflags
./curl-config --libs*/
Вместо этого: sudo apt-get install libcurl4-openssl-dev
Описание утилиты CURL http://rus-linux.net/MyLDP/internet/curlrus.html
Описание работы на С++ на русском:
http://programmersforum.ru/showthread.php?t=60338

Для обработки XML файла установить:
sudo apt-get install libtinyxml-dev

//Для вывода символов на экран требуется Windows-1251 - т.к. там это закодированно программой
//Преобразования UTF-8 ->Windows-1251 можно выполнить с помощью

    //UTF8 to/from wide char conversion in STL
    //http://stackoverflow.com/questions/148403/utf8-to-from-wide-char-conversion-in-stl

    //Simple iconv (libiconv) example
    //http://blog.inventic.eu/2010/11/simple-iconv-libiconv-example/
    //http://dendroudnotes.blogspot.ru/2011/02/iconv-c.html


Можно сделать отдельную программу-конвертор, которая бы использовала .h файл со шрифтом и формировала бинарный файл с компактной структорой, т.е. отсутсвием лишних нулей
и модуль загрузки шрифта - развертывание в памяти массива данных = исключить некрасивость в коде

НЕТ: Также можно было бы сделать перестановку символов в код UTF-8, чтобы избежать лишней перекодировки при каждом выводе на экран
НЕТ: Т.е. набор чисел от 0 до 256 необходимо преобразовать в другую кодировку, а потом данные символов расставить в нужном порядке
Не получиться - UTF-8 при установленном 1 бите числа является многобайтовым, что приводит к очень сложному кодированию до 4 байт длины
http://ru.wikipedia.org/wiki/UTF-8
Т.е. по любому требуется преобразование к 255 символам

Хранение шрифтов, преобразование к удобному виду вынести в отдельный класс (файл) - типа фабрика - static метод возвращающий готовый класс


Можно на выходе сформировать 2 массива: 1 содержит ширину каждого символа, 2 содержит просто огромный масссив данных (не будет лишних нулей и он займет меньше места в памяти)
при загрузке сформировать массив Symbol - суммирование указателя и ширины символа
class Symbol
{
ushort width;
unsigned char* data;
}
символ должен уметь рисовать сам себя

Ещё можно разместить данные шрифта в более удобном виде - переставить порядок следования байт, чтобы копирование можно было осуществлять последовательно

Посмотреть другие форматы, возвращаемые программой sym и т.д.

ОШИБКИ!!! Т.е. имеет место в этом проекте изначальная ошибка проектирования - его вообще не было
ОШИБКИ!!! Была попытка вместо преобразования шрифтов к удобному виде подстроиться по эти данные

Можно сделать не векторы, а строки отображаются на один непрерывный участок памяти, где 1 байт команда для дисплея - экономия на копировании данных
Так они копируются 2 раза - в буфер экрана, а затем в буфер шины I2C
Т.е. можно выполнить в виде ещё одного класса View

Debug_output_console();
Сделать функцию во View - выводящую содержимое View на терминал в виде звезедочек - почти помещается (лучше использовать кодирование по 2 символа в одном экранном символе)
█▌▐

Лучше что были символы по квадратиками - т.е. по 4 в одном эранном символе
▀▄█▌▐

▀▄█

Можно выводить в файл и при отображении изменить в настройках окна консоли выводимый шрифт - сделать его размер минимальным
Символы выводяться по 8 бит вертикально - т.е. можно объединить по 2 по вертикали ▀▄█
Вначале сформировать массив строк 133х32 и туда записывать, после вывод на экран

По идее кодировать можно компактнее - но не хватает всех комбинаций
использовать псевдографические символы (▖▗▝▝▘▞▚▙▟▛▜)
Так можно выводить QR код на экран
и организовать передачу информации - вывод 1 раз в секунду

█▄▌▐▀
▖▗▘▙▚▛▜▝▞▟
▐
▀ 	▁ 	▂ 	▃ 	▄ 	▅ 	▆ 	▇ 	█ 	▉ 	▊ 	▋ 	▌ 	▍ 	▎ 	▏


23
01

Вес каждой позиции 2^n
48
12
Итоговый массив
 ▖▗▄▘▌▚▙▝▞▐▟▀▛▜█
0123456789012345

Псевдографика
http://ru.wikipedia.org/wiki/%D0%9F%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA%D0%B0

\x1B[32F
Как управлять курсором и цветом (\x1b[30m)
http://ru.wikipedia.org/wiki/%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B5_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8_ANSI
http://en.wikipedia.org/wiki/ANSI_escape_code

Решение: т.к. шрифты уже сгенерированы и проверены на экране - использовать их

Лучше Debug делать в BMP файл
http://easybmp.sourceforge.net/
16-bit файл не прочитался ни одним Viewer
допустимое число бит цвета 1,4,8,16,24
Минус - всегда хранить по 4 байта на пиксель, независимо от выбранного формата

BMP AnImage;
AnImage.SetSize(133,64);
AnImage.SetBitDepth(24);

for(ushort i=0;i<64;i++)
{
AnImage(i,i)->Red = 255;
AnImage(i,i)->Green = 0;
AnImage(i,i)->Blue = 0;
AnImage(i,i)->Alpha = 0;
}

c++ gif library
http://giflib.sourceforge.net/gif_lib.html
Fast Graphics library which can support Animated GIFs
http://stackoverflow.com/questions/7142451/fast-graphics-library-which-can-support-animated-gifs

Нужно при выводе текста указывать точные координаты - пуская будет деление на 8 с округлением в меньшую сторону

РЕШЕНО: Для каждого пикселя использовать 1 байт - при выводе на дисплей преобразовывать при выводе в буфер = зато многие вещи будет проще делать, в том числе м вывод видео
тогда есть оправдание 2 буферам и кодирование производиться в одном месте = гарантированно меньше проблем
1Кб против 8Кб = разница никакая
шрифты хранить также

ВНИМАНИЕ: vector не очищает буфер - там много левых данных

ВЫВОД: не стоит усложнять хитрыми пересчетами, рассчитать число используемых ресурсов и возможности создаваемого функционала.
View - получается независим от аппаратной реализации экрана TIC149

Возможно стоит заменить во всех местах ushort на short - т.к. например в таком случае текст сможет выезжать на экран
short -32768 +32768 вполне достаточно для экранных координат

const short - не имеет смысла во многих случаях = только приводит к появлению лишней переменной

Для рисования линий и окружностей использовать - Алгоритм Брезенхэма
http://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%91%D1%80%D0%B5%D0%B7%D0%B5%D0%BD%D1%85%D1%8D%D0%BC%D0%B0

OK - проверка вывода на экран несколько страниц в цикле
У текста и View свойство быть прозрачным, т.е. выводяться на экран только заполненные пикселы
Можно реализовать вывод 2 пересекающихся текстов на реальном (3) видовом экране

ТЕКУЩЕЕ:
вывод текса, линий, окружностей за пределы экрана

Загрузку организовать в виду синглтон объекта стр.132 - в книге описан самый примитивный вариант
Приемы объектно-ориентированного проектирования. Паттерны проектирования
http://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%B8%D0%BD%D0%BE%D1%87%D0%BA%D0%B0_%28%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%29#.D0.9F.D1.80.D0.B8.D0.BC.D0.B5.D1.80_.D0.BD.D0.B0_C.2B.2B

ЛУЧШЕЕ: Улучшенная версия классической реализации Singleton - три варианта реализации на C++: Стандартная, Майерса, улучшенный Майерса
http://cpp-reference.ru/patterns/creational-patterns/singleton/

Применение шаблонов языка C++.
http://www.rsdn.ru/article/patterns/singleton.xml
Хорошая реализация в виде шаблона с подсчетом ссылок и автоудалением, когда ссылки кончились
Шаблон можно хранить в отдельном файле и повторно использовать
Но там реализация не Маерса - нужно будет удалять вручную созданный единственный экземпляр
Отдельно класс Singleton и наследование от него класса Font

Шрифты - инициализация
1) Можно массив символов сделать членом класс - для этого
typedef constexpr static sUnitN<SYM_16_LONG*PART_COUNT16> sUnit16;
Но возникает проблема - получается 2 экземпляра в классах LCD_TIC149 и LCD_TIC149_Fast

Если не использовать constexpr static - тоже компилируется и работает, но кажется шрифты будут в каждом экземпляре этого класса
//Т.е. без объявления const static - работает? Что получается копируется в каждый экземпляр класа?
short sdf[1]={1};
constexpr static short sdf[1]={1};

#include вставить прямо в опредение класса в private:
//Получаются или глобальные переменные или будет происходить инициализация массива с каждым экземпляром класса?
#include "Arial_8.h"
#include "Tahoma_16.h"
#include "Tahoma_24.h"
#include "Tahoma_32.h"

Размер бинарного файла уже 527Kb

2) ИСПОЛЬЗУЕТСЯ: Можно использовать как глобальные переменные - объявление в одном месте, в других доступно через extern
Проще и размер файла стал 226.4 KiB
После уменьшения размеров массивов шрифтов до реального количества байт в символе - размер стал 205Kb

3)Может вынести шрифты в отдельные файлы? упакованные - первые 512 байт (256 байт) - таблица ширин, затем без лишних нулей данные самих символов
Позволит уйти от извращенного .h файла - меньше займет памяти
При загрузке рассчитать таблицу указателей на каждый символ используя ширину символа
Еще можно преобразовать в непрерывный массив с таблицей ширин вначале = займет меньше памяти
Но потребуется отдельный конвектор - в отдельной папке
Или ЛУЧШЕ пропарсить .h файл скриптом на Python или bash и удалить лишнее
т.е. преобразовать к одномерному массиву
тогда сохраниться визуальный образ шрифта в .h файле
ВНИМАНИЕ в каждом элементе массива нет последней запятой

4) Шрифты в linux
http://rus-linux.net/lib.php?name=/MyLDP/sys-conf/fonts.html

Деструктор наследуемого класса всегда делать виртуальным?
Иначе при удалении указателя на родительский класс будет вызван не тот деструктор

Разбиение на файлы - в каждом файле содержиться по одному классу:
В .h файлах не делать #include на определения классов - просто кратко описывать - class Font;
#include делать только в .cc файлах
Но в случае если создается экземпляр объекта (или класс наследуется от него), а не описывается ссылка или указатель на него, то нужно полное описание = нужно включать #include
#include "sSymbol.h"
//class sSymbol;

Проблема в том, что надпись только поднимается, но не опускается возможно в типах данных
не было прописанно по умолчанию signed char


    /*std::string str;
    //for(short i=32;i<255;i++) str+=i;
    str="РўРµСЃС‚РѕРІР°СЏ СЃС‚СЂРѕРєР°!Тестовая строка!";
    std::cout << str << std::endl;
    //Все символы <32 выводить пробел?

    std::string str4=View_LCD::recodeUTF8toCP1251(str);
    std::cout << str4 << std::endl;

    std::string str5=View_LCD::iconv_recode("CP1251","UTF-8",str);;
    std::cout << str5 << std::endl;*/

    /*for(int a=0;a<32;a++)
    {
    for(int y=0;y<133/2;y++)
    {
    	std::cout << "▀ ";
    	//std::cout << "█ ";//▌▐";//y%10;
    	//std::cout << "▌";//▌▐";//y%10;
    }
    std::cout << std::endl;
    }*/
    //Возврат к началу экрана
    //CSI n F 	CPL – Cursor Previous Line 	Перемещает курсор в начало n-ой (по умолчанию 1-ой) строки сверху относительно текущей.
    //std::cout << "\x1B[32F" << "*Currect position*" << std::endl;
    //std::cout << "\x1b[3m"; Цвет не прошел

    //std::cerr<<"Standart Error"<<std::endl;

void test_display_fast()
{
    I2CBus mI2CBus("/dev/i2c-1",0x3c);
    LCD_TIC149_Fast* mLCD_TIC149_Fast=new LCD_TIC149_Fast(&mI2CBus,61);
    mLCD_TIC149_Fast->clear_lcd_hardware();
    //mLCD_TIC149_Fast->lcd_output_hardware_logo();

    mLCD_TIC149_Fast->print_lcd_24(0,0,"VALEK красавец");
    mLCD_TIC149_Fast->print_lcd_16(0,3,"VALEK красавец");
    mLCD_TIC149_Fast->print_lcd_8(0,5,"VALEK красавец");
    mLCD_TIC149_Fast->print_lcd_32(0,6,"012345");

    mLCD_TIC149_Fast->print_lcd_32(0,0,"0123456");
    mLCD_TIC149_Fast->print_lcd_32(0,4,"7890123");

    //Вывод из буфера на экран
    mLCD_TIC149_Fast->push_buffer_to_lcd_screen();
}

void test_display()
{
    I2CBus mI2CBus("/dev/i2c-1",0x3c);
    LCD_TIC149* mLCD_TIC149=new LCD_TIC149(&mI2CBus,61);

    //mLCD_TIC149->lcd_view_invert();
    mLCD_TIC149->clear_lcd_hardware();
    mLCD_TIC149->print_lcd(Fnt::h8,0,0,"1234567890",true);
    mLCD_TIC149->print_lcd(Fnt::h16,0,8,"VALEK красавец",true);
    mLCD_TIC149->print_lcd(Fnt::h24,0,24,"1DFG",true);
    mLCD_TIC149->line(0,0,132,63);
    mLCD_TIC149->push_buffer_to_lcd_screen();

    /*m_View_LCD->point(0,0);
    m_View_LCD->line(0,0,132,63);
    m_View_LCD->rectangle(0,0,132,63);//Т.к. нумерация с 0
    m_View_LCD->circle(64,32,32);

    //m_View_LCD->print_lcd(Font_height::h8,0,0,"1234567890");
    m_View_LCD->print_lcd(Fnt::h8,0,0,"1234567890",true);
    m_View_LCD->print_lcd(Fnt::h16,0,8,"VALEK красавец",true);
    m_View_LCD->print_lcd(Fnt::h24,0,24,"1DFG",true);

    m_View_LCD->save_to_bmp(AnImage);
    AnImage.WriteToFile("Output.bmp");
    //m_View_LCD->debug_output_console();
    m_View_LCD->debug_output_console_compact();*/
}

    BMP AnImage;
    //AnImage.SetSize(133,64);
    AnImage.SetBitDepth(1);

    //test_display_fast();
    //test_display();
    //return 0;


Для управления выходами использовать
git clone https://github.com/alanbarr/RaspberryPi-GPIO


***** СТАРОЕ

Компиляция одного файла
gcc main.cc -o main

С использованием std заработало только при
g++ main.cc -o main

Периодически возникает ошибка
classA.h:1:1: error: unknown type name ‘class’
classA.h:2:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘{’ token
РЕШЕНИЕ: повторная перекомпиляция
Что-то часто возникают подобные ошибки - нужен ReBuild All?

Запуск sudo ./main


const int* - слева от * - данные
int* const - справа от * - константный указатель
http://books.google.ru/books?id=uPvvxRYj-NIC&pg=PA380&lpg=PA380&dq=C%2B%2B+const+%D1%81%D0%BB%D0%B5%D0%B2%D0%B0+%D0%BE%D1%82+*&source=bl&ots=K5mme-V8bM&sig=tPk_0Vzqx5yivPZRbK9VykQnijY&hl=ru&sa=X&ei=V2n8UsHLF_H44QTw0ICoAQ&ved=0CC8Q6AEwAQ#v=onepage&q=C%2B%2B%20const%20%D1%81%D0%BB%D0%B5%D0%B2%D0%B0%20%D0%BE%D1%82%20*&f=false


//Страуструп - прочитано 5-5.2
Читать 5.3 - Но перед этим нужно прочитать главу 3 - т.к. код построен на программе калькулятор стр. 70


Основной проект:
компиляция sudo make
запуск sudo ./prog


